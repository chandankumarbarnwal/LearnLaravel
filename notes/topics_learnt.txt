LARAVEL CHEAT SHEET
   https://github.com/piotr-jura-udemy/laravel-cheat-sheet/blob/master/0026-assets.md

-------------------------------------------------------------------------------------------------------

   ARTISAN COMMAND

   1. php artisan serve => to run laravel project

   2. php artisan route:list => to get the list of route of both(api.php and web.php)

   3. php artisan make:controller HomeController => to create controller 

   4. php artisan migrate => to make database table migration

   5. php artisan make:migration create_blogposts_table => to create table migration 

   6. php artisan migrate:refresh

   7. php artisan migrate:rollback

   8. php artisan make:model BlogPost => create BlogPost model only

   9. php artisan make:model BlogPost -m =>create BlogPost model and blog_posts migration also

   10. php artisan make:request StorePost => for form Requests means custom class validation
   
   11. php artisan make:test BlogTest => to create test file for testing purpose

   12. php artisan tinker


-------------------------------------------------------------------------------------------------------------

Working with webpack:


Laravel Mix provides a fluent API for defining webpack build steps for your application using several common CSS and JavaScript pre-processors.


1.  npm install =>to include all the libraries of version available in package.json

2.  npm run dev => 1.  which run the script availabe inside package.json
                  
                   2. To run your Mix tasks you only need to execute one of the NPM scripts 
                     that is included with the default Laravel package.json file

                   3. When we do change anything in css or js file then to execute these file

3.  npm run watch => to see the current changes.                  

4. To include js => <script type="text/javascript" src="{{  mix('js/app.js') }}"></script>

5. To include css =>  <link rel="stylesheet" type="text/css" href="{{ mix('css/app.css') }}">

--------------------------------------------------------------------------------------------------------------

GITHUB

Clone or download project folder from github

1. run command composer install => to include all the composer package file

2. npm install => to include all the npm packages

3. create .env file in main folder and copy all .env.example and change database and password


--------------------------------------------------------------------------------------------------------------
LARAVEL TEST

1. To make sure  that application works as expected. To Check all module is working fine. Beacuse when  application grows then it will be dificult to verify all module.

2. types of test:

    i. unit tests: to testing small isolated part of our code/application like one class or one method functionality.

    ii. feature tests  : For testing specific feature of our application. It might be to test BlogPost is saved when we are sending correct data and if we see the flash message that bolgpost was created successfully.

    often it is involed to check http requests when running our application

3. Typical test consists 3 parts:

  ex: $object = new BlogPost(); => arrange
      $object->save(); => act
      $this->assertTrue(); => assert


    1. Arrange: => its optional. Where we arrange data.test set up, like creating an object to be tested or mocks

    2. Act: => Where we do something, we perform some task. execute the objects created in the Arrange step

    3. assert: => Where we verify our completed task. check and verify the result from the Act step against expected results



4. to execute test run command => .vendor/bin/phpunit


-----------------------------------------------------------------------------------------------------
  ONE TO ONE RELATIONSHIP

  Parent 

    class Author extends Model
{
    public function profile()
    {
        // can not contain profile_id beacuse without author profile can't exist
           return $this->hasOne('App\Profile'); 
    }
}

child 

class Profile extends Model
{
    public function author()
    {
      return $this->belongsTo('App\Author');  // contain author_id
    }
}



SAVE DATA

Using AUTHOR:

$author = App\Author:;create();
$profile = new App\Profile;
$author->profile()->save($profile);

$author = App\Author:;create();
$profile = new App\Profile;
$profile()->author()->associate($author)->save();


-----------------------------------------------------------------------------------------

LAZY LOADING VS EAGER LOADING

  Lazy loading => Dynamic properties are "lazy loading", meaning they will only load their relationship data when we actually access them.

   Because of this, developers often use eager loading to pre-load relationships they know will be accessed after loading the model. Eager loading provides a significant reduction in SQL queries that must be executed to load a model's relation


    $profiles = Profile::all(); // "select * from `profiles`" // query 1




foreach ($profiles as $profile) {
    echo $profile->author->author_id; // select * from `authors` where `authors`.`id`= $profile->id //query 5// executing once for each id
}


//TOTAL QUERY RUN 6
  $profile = App\Profile::find(2);

  $profile->author

  Eager Loading: => When accessing Eloquent relationships as properties, the relationship data is "lazy loaded". 

When accessing Eloquent relationships as properties, the relationship data is "lazy loaded". This means the relationship data is not actually loaded until you first access the property. However, Eloquent can "eager load" relationships at the time you query the parent model. Eager loading alleviates the N + 1 query problem. To illustrate the N + 1 query problem, consider a Book model that is related to Author:



$profiles = Profile::with(['author'])->get();
First execute : "select * from `profiles`"  // 1 query

Get all id then execute with all id at once 

 "select * from `authors` where `authors`.`id` in (1, 2, 5, 6, 7)" // 1query total 2 query


foreach ($profiles as $profile) {
    echo $profile->author->author_id; 
}

=================================================================================================
 RELATED TO MODEL FUNCTION

1. calling function parameters

class Comment extends Model
{
    public function blogPost()
    {

      //Here comment table related with blogPost table.
      //calling blogpost model from comment model
      //When calling blogPost model then need to specify,
      // column name of comment table(blog_post_id) is related with the column name of blog post table(id)
      // If it same as laravel convention then no need to write column name
      return $this->belongsTo('App\BlogPost', 'blog_post_id => of comment table', 'id => of blog_posts table');

    }
}


2. function name convention

  function name blogPost  => Because related column/foreign name is blog_post_id, so by default laravel will look funtion blogPost and it convert to blog_post and suffix _id. Means first look funtion table name and with suffix id 
=================================================================================================

function name used:
1. saveMany([$c1, $c2]):=> save more then one object related values. 
						    If you need to save multiple related models:

      $bp = BlogPost::find(2);
      $c1 = new comment;
      $c1->content = 'c1 content';
       $c2 = new comment;
      $c2->content = 'c2 content ';
      $bp->comment()->saveMany([$c1, $c2]);


2. has('comments') =>  to get related comment of blogpost. here we can put count condition also.   
		retrieve all blog posts that have at least one comment.

			// Retrieve all posts that have at least one comment...
			$posts = App\Post::has('comments')->get();

			You may also specify an operator and count to further customize the query:

			// Retrieve all posts that have three or more comments...
			$posts = App\Post::has('comments', '>=', 3)->get();


4. doesntHave => 	opposite of "has" method.
					
					The absence of a relationship. To retrieve all blog posts that don't have any comments.
					
					$posts = App\Post::doesntHave('comments')->get();


5 .whereHas => same as "has" method but it accept clouser as where clause parameters. 
					To put "where" conditions on your "has" queries.

 BlogPost::whereHas('comment',function ($query) {$query->where('content','like','%abc%');  })->get();


 BlogPost::whereHas('comment',function ($query) {$query->where('content','like','%abc%');  },'>=',2)->get();


6. whereDoesntHave => opposite of 'whereHas' method.
						To put "where" conditions on your "doesntHave" queries.


		 BlogPost::whereDoesntHave('comment', function($query){  $query->where('content', 'like', '%abc%')     ;})->get();


7.  withCount => 

			If you want to count the number of results from a relationship without actually loading them you may use the "withCount" method, which will place a {relation}_count(relationFunctionName_count) column on your resulting models. For example:

			BlogPost::withCount('comment')->get();

			You may add the "counts" for multiple relations as well as add constraints to the queries:

			$posts = App\Post::withCount(['votes', 'comments' => function (Builder $query) {
			    $query->where('content', 'like', 'foo%');
			}])->get();

			
			You may also alias the relationship count result, allowing multiple counts on the same relationship:
				--with new_comment
			BlogPost::withCount(['comment',
				'comment as new_comment'=> function($query){$query->where('created_at', '>=', '2020-06-13 01:48:39');}
			])->get();
					--with new_comment, old_comment

			BlogPost::withCount(['comment',
				'comment as new_comment'=> function($query){$query->where('created_at', '>=', '2020-06-13 01:48:39') ;},
				'comment as old_comment' =>function($query) { $query->where('created_at','<=', '2020-06-13 01:48:39') ;}
			])->get();

			To reterive specific column use "select" statement, call 'withCount' after the "select" method:

			BlogPost::select('content')->withCount(['comment'])->get();

			BlogPost::select('content')->withCount(['comment',
				'comment as new_comment'=> function($query){$query->where('created_at', '>=', '2020-06-13 01:48:39') ;},
				'comment as old_comment' =>function($query) { $query->where('created_at','<=', '2020-06-13 01:48:39') ;}
			])->get();


			In addition, using the loadCount method, you may load a relationship count after the parent model has already been retrieved:


8. 

